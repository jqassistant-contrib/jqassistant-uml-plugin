<jqassistant-rules
	xmlns="http://schema.jqassistant.org/rule/v1.8"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://schema.jqassistant.org/rule/v1.8 https://schema.jqassistant.org/rule/jqassistant-rule-v1.8.xsd">

	<group id="default">
		<includeConstraint refId="petclinic:*"/>
	</group>

	<!-- tag::petclinicComponent[] -->
	<concept id="petclinic:Component">
		<description>Every package contained in the root package 'org.springframework.samples.petclinic' represents a `Component`.</description>
		<cypher><![CDATA[
		MATCH
		  (:Main:Artifact)-[:CONTAINS]->(rootPackage:Java:Package)-[:CONTAINS]->(component:Java:Package)
		WHERE
		  rootPackage.fqn="org.springframework.samples.petclinic"
		SET
		  component:Component
		RETURN
		  component as Component
   		]]>
		</cypher>
	</concept>
	<!-- end::petclinicComponent[] -->

	<!-- tag::petclinicComponentDependency[] -->
	<concept id="petclinic:ComponentDependency">
		<requiresConcept refId="petclinic:Component"/>
		<description>A Java component depends on another Java component ("DEPENDS_ON_COMPONENT") if there exists a dependency
			between Java types contained in these components (including Java types in sub-packages of the components).</description>
		<cypher><![CDATA[
		MATCH
		  (component1:Java:Package:Component)-[:CONTAINS*]->(type1:Java:Type),
		  (component2:Java:Package:Component)-[:CONTAINS*]->(type2:Java:Type),
		  (type1)-[dependsOn:DEPENDS_ON]->(type2)
		WHERE
		  component1 <> component2
		WITH
		  component1, component2, count(dependsOn) as weight
		MERGE
		  (component1)-[dependsOnComponent:DEPENDS_ON_COMPONENT]->(component2)
		SET
		  dependsOnComponent.weight=weight
		RETURN
		  component1 as Dependent, component2 as Dependency, weight as Weight
		ORDER BY
		  weight desc
   		]]>
		</cypher>
	</concept>
	<!-- end::petclinicComponentDependency[] -->

	<!-- tag::petclinicComponentDefinedByUMLComponent[] -->
	<concept id="petclinic:ComponentDefinedByUMLComponent">
		<requiresConcept refId="petclinic:Component"/>
		<requiresConcept refId="xmi:UMLPackage"/>
		<requiresConcept refId="xmi:UMLComponent"/>
		<description>A Java "Component" package is defined by ("DEFINED_BY") by a UML "Component" having the same name which is contained in the UML model package `Components`.</description>
		<cypher><![CDATA[
		MATCH
		  (component:Java:Package:Component),
		  (:UML:Package{name:"Components"})-[:HAS_CHILD]->(umlComponent:UML:Component)
		WHERE
		  component.name = lower(umlComponent.name)
		MERGE
		  (component)-[:DEFINED_BY]->(umlComponent)
		RETURN
		  component as Component, umlComponent.name as UMLComponent
   		]]>
		</cypher>
	</concept>
	<!-- end::petclinicComponentDefinedByUMLComponent[] -->

	<!-- tag::petclinicUndefinedComponent[] -->
	<constraint id="petclinic:UndefinedComponent">
		<requiresConcept refId="petclinic:Component"/>
		<requiresConcept refId="petclinic:ComponentDefinedByUMLComponent"/>
		<description>.</description>
		<cypher><![CDATA[
		MATCH
		  (component:Package:Component)
		WHERE NOT
		  (component)-[:DEFINED_BY]->()
		RETURN
		  component as UndefinedComponent
   		]]>
		</cypher>
	</constraint>
	<!-- end::petclinicUndefinedComponent[] -->

	<!-- tag::petclinicUnusedComponent[] -->
	<constraint id="petclinic:UnusedComponent">
		<requiresConcept refId="petclinic:Component"/>
		<requiresConcept refId="petclinic:ComponentDefinedByUMLComponent"/>
		<description>.</description>
		<cypher><![CDATA[
		MATCH
		  (component:UML:Component)
		WHERE NOT
		  ()-[:DEFINED_BY]->(component)
		RETURN
		  component as UnusedComponent
   		]]>
		</cypher>
	</constraint>
	<!-- tag::petclinicUnusedComponent[] -->

	<!-- tag::petclinicUndefinedComponentDependency[] -->
	<constraint id="petclinic:UndefinedComponentDependency">
		<requiresConcept refId="petclinic:ComponentDependency"/>
		<requiresConcept refId="petclinic:ComponentDefinedByUMLComponent"/>
		<requiresConcept refId="xmi:UMLDependency"/>
		<description>.</description>
		<cypher><![CDATA[
		MATCH
		  (component1:Package:Component)-[:DEFINED_BY]->(umlComponent1:UML:Component),
		  (component2:Package:Component)-[:DEFINED_BY]->(umlComponent2:UML:Component),
		  (component1)-[:DEPENDS_ON_COMPONENT]->(component2)
		WHERE NOT
		  (umlComponent1)-[:HAS_DEPENDENCY]->(umlComponent2)
		RETURN
		  component1 as Dependent, component2 as UndefinedDependency
		]]></cypher>
	</constraint>
	<!-- end::petclinicUndefinedComponentDependency[] -->

	<!-- tag::petclinicUnusedComponentDependency[] -->
	<constraint id="petclinic:UndefinedComponentDependency">
		<requiresConcept refId="petclinic:ComponentDependency"/>
		<requiresConcept refId="petclinic:ComponentDefinedByUMLComponent"/>
		<requiresConcept refId="xmi:UMLDependency"/>
		<description>.</description>
		<cypher><![CDATA[
		MATCH
		  (component1:Package:Component)-[:DEFINED_BY]->(umlComponent1:UML:Component),
		  (component2:Package:Component)-[:DEFINED_BY]->(umlComponent2:UML:Component),
		  (umlComponent1)-[:HAS_DEPENDENCY]->(umlComponent2)
		WHERE NOT
		  (component1)-[:DEPENDS_ON_COMPONENT]->(component2)
		RETURN
		  umlComponent1 as Dependent, umlComponent2 as UnUsedDependency
		]]></cypher>
	</constraint>
	<!-- end::petclinicUnusedComponentDependency[] -->
</jqassistant-rules>
